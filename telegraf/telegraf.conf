[agent]
  interval = "1s"
  flush_interval = "1s"
  debug = true
  quiet = false
  logfile = ""

# 1️⃣  INPUT: MQTT – oryginalny JSON z Arduino
[[inputs.mqtt_consumer]]
  servers = ["tcp://mosquitto:1883"]
  topics  = ["traffic/status"]
  qos = 0
  client_id = "telegraf_traffic_logger"
  data_format = "json"
  json_time_key = "t"
  json_time_format = "unix_ms"

# 2️⃣  PROCESSOR: Starlark – konwersja na kompletne metryki
[[processors.starlark]]
  source = '''
def apply(metric):
    names  = ["TLS1 IN", "TLS2 OUT", "TLS9 IN", "TLS10 OUT"]
    states = ["RED", "GREEN", "YELLOW", "RED_YELLOW"]

    # czas z Arduino (już ustawiony przez json_time_key = "t")
    ts_ms = int(metric.time / 1000000)
    out = []

    # --- DEKODOWANIE WARUNKÓW Z POLA "b" ---

    b = metric.fields.get("b", None)

    cond_valid = False
    cond_day_night = "unknown"
    cond_dry_rain  = "unknown"
    cond_peak      = "unknown"

    if (b != None) and (b != "-1") and (len(b) >= 3):
        cond_valid = True

        # b[0]: d/n -> day / night
        if b[0] == "d":
            cond_day_night = "day"
        elif b[0] == "n":
            cond_day_night = "night"

        # b[1]: d/r -> dry / rain
        if b[1] == "d":
            cond_dry_rain = "dry"
        elif b[1] == "r":
            cond_dry_rain = "rain"

        # b[2]: o/r -> off-peak / rush
        if b[2] == "o":
            cond_peak = "off_peak"
        elif b[2] == "r":
            cond_peak = "rush"

    # --- ROZWINIĘCIE L[0..3] NA METRYKI traffic_light ---

    for i in range(4):
        prefix = "l_%d_" % i
        cars = int(metric.fields.get(prefix + "c", 0))
        sraw = int(metric.fields.get(prefix + "s", -1))
        wraw = int(metric.fields.get(prefix + "w", 0))
        dur  = int(metric.fields.get(prefix + "d", 0))

        state = "UNKNOWN"
        if (sraw >= 0) and (sraw < len(states)):
            state = states[sraw]

        m = Metric("traffic_light")
        m.time = ts_ms * 1000000
        m.tags["id"] = str(i)
        m.tags["name"] = names[i]

        # pola związane ze światłem
        m.fields["cars"] = cars
        m.fields["red_duration_ms"] = dur
        m.fields["will_turn_green"] = (wraw != 0)
        m.fields["state"] = state

        # pola związane z warunkami z telefonu (te same dla wszystkich 4 świateł)
        m.fields["cond_valid"] = cond_valid       # bool: czy b jest ustawione ( != -1 )
        m.fields["cond_day_night"] = cond_day_night
        m.fields["cond_dry_rain"]  = cond_dry_rain
        m.fields["cond_peak"]      = cond_peak
        m.fields["cond_raw"]       = b if b != None else ""

        out.append(m)

    return out
'''

# 3️⃣  PROCESSOR: execd – dopisanie pola recorded_at_ms z bieżącym czasem (ms)
[[processors.execd]]
  command = ["python3", "/etc/telegraf/add_recorded_ts.py"]

# 4️⃣  OUTPUT: do logu – kontrola danych po transformacji
[[outputs.file]]
  files = ["stdout"]
  data_format = "influx"

# 5️⃣  OUTPUT: do InfluxDB v3 – gotowe metryki
[[outputs.influxdb_v2]]
  urls = ["http://influxdb3-core:8181"]
  token = "${INFLUXDB_TOKEN}"
  organization = "${INFLUXDB_ORG}"
  bucket = "${INFLUXDB_BUCKET}"
  timeout = "5s"
  precision = "ms"

[agent]
  interval = "1s"
  flush_interval = "1s"
  debug = true
  quiet = false
  logfile = ""

# 1️⃣  INPUT: MQTT – oryginalny JSON z Arduino
[[inputs.mqtt_consumer]]
  servers = ["tcp://mosquitto:1883"]
  topics  = ["traffic/status"]
  qos = 0
  client_id = "telegraf_traffic_logger"
  data_format = "json"
  json_time_key = "t"
  json_time_format = "unix_ms"

# 2️⃣  PROCESSOR: Starlark – konwersja na kompletne metryki
[[processors.starlark]]
  source = '''
def apply(metric):
    names  = ["TLS1 IN", "TLS2 OUT", "TLS9 IN", "TLS10 OUT"]
    states = ["RED", "GREEN", "YELLOW", "RED_YELLOW"]

    ts_ms = int(metric.time / 1000000)     # czas z Arduino
    out = []

    for i in range(4):
        prefix = "l_%d_" % i
        cars = int(metric.fields.get(prefix + "c", 0))
        sraw = int(metric.fields.get(prefix + "s", -1))
        wraw = int(metric.fields.get(prefix + "w", 0))
        dur  = int(metric.fields.get(prefix + "d", 0))

        state = "UNKNOWN"
        if (sraw >= 0) and (sraw < len(states)):
            state = states[sraw]

        m = Metric("traffic_light")
        m.time = ts_ms * 1000000
        m.tags["id"] = str(i)
        m.tags["name"] = names[i]
        m.fields["cars"] = cars
        m.fields["red_duration_ms"] = dur
        m.fields["will_turn_green"] = (wraw != 0)
        m.fields["state"] = state
        out.append(m)

    return out
'''

# 3️⃣  PROCESSOR: execd – dopisanie pola recorded_at_ms z bieżącym czasem (ms)
[[processors.execd]]
  command = ["python3", "/etc/telegraf/add_recorded_ts.py"]

# 4️⃣  OUTPUT: do logu – kontrola danych po transformacji
[[outputs.file]]
  files = ["stdout"]
  data_format = "influx"

# 5️⃣  OUTPUT: do InfluxDB v3 – gotowe metryki
[[outputs.influxdb_v2]]
  urls = ["http://influxdb3-core:8181"]
  token = "${INFLUXDB_TOKEN}"
  organization = "${INFLUXDB_ORG}"
  bucket = "${INFLUXDB_BUCKET}"
  timeout = "5s"
  precision = "ms"
